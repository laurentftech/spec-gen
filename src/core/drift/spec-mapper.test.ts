/**
 * Tests for spec-mapper module
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  parseSpecHeader,
  parseSpecReferences,
  inferDomainFromPath,
  buildSpecMap,
  matchFileToDomains,
  parseADRRelated,
  buildADRMap,
} from './spec-mapper.js';

// ============================================================================
// TEST HELPERS
// ============================================================================

async function createTempDir(): Promise<string> {
  const dir = join(tmpdir(), `spec-mapper-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  await mkdir(dir, { recursive: true });
  return dir;
}

const SAMPLE_SPEC = `# Auth Specification

> Generated by spec-gen v1.0.0 on 2025-01-30
> Source files: src/auth/login.ts, src/auth/register.ts

## Purpose

Manages authentication and authorization.

## Entities

### User

| Property | Type | Description |
|----------|------|-------------|
| email | string | User email |
| password | string | Hashed password |

### Session

| Property | Type | Description |
|----------|------|-------------|
| token | string | JWT token |

## Requirements

### Requirement: UserLogin

The system SHALL authenticate users via email and password.

#### Scenario: ValidLogin
- **GIVEN** valid credentials
- **WHEN** login is attempted
- **THEN** a session token is returned

### Requirement: UserRegistration

The system SHALL allow new user registration.

## Technical Notes

- **Implementation**: \`src/auth/middleware.ts\`, \`src/auth/jwt.ts\`
- **Dependencies**: user domain
`;

const OVERVIEW_SPEC = `# System Overview

> Generated by spec-gen v1.0.0 on 2025-01-30

## Purpose

System overview specification.

## Domains

- auth: Authentication and authorization
- user: User management
`;

// ============================================================================
// PARSE SPEC HEADER TESTS
// ============================================================================

describe('parseSpecHeader', () => {
  it('should extract source files from header', () => {
    const result = parseSpecHeader(SAMPLE_SPEC);
    expect(result.sourceFiles).toEqual(['src/auth/login.ts', 'src/auth/register.ts']);
  });

  it('should extract generated date', () => {
    const result = parseSpecHeader(SAMPLE_SPEC);
    expect(result.generatedDate).toBe('2025-01-30');
  });

  it('should handle spec with no source files header', () => {
    const spec = `# Test Spec\n\n## Purpose\n\nSome content.`;
    const result = parseSpecHeader(spec);
    expect(result.sourceFiles).toEqual([]);
    expect(result.generatedDate).toBeNull();
  });

  it('should handle backtick-wrapped filenames in source header', () => {
    const spec = '> Source files: `src/a.ts`, `src/b.ts`';
    const result = parseSpecHeader(spec);
    expect(result.sourceFiles).toEqual(['src/a.ts', 'src/b.ts']);
  });

  it('should handle singular "Source file" label', () => {
    const spec = '> Source file: src/single.ts';
    const result = parseSpecHeader(spec);
    expect(result.sourceFiles).toEqual(['src/single.ts']);
  });
});

// ============================================================================
// PARSE SPEC REFERENCES TESTS
// ============================================================================

describe('parseSpecReferences', () => {
  it('should extract implementation files from Technical Notes', () => {
    const result = parseSpecReferences(SAMPLE_SPEC);
    expect(result.files).toContain('src/auth/middleware.ts');
    expect(result.files).toContain('src/auth/jwt.ts');
  });

  it('should extract requirement names', () => {
    const result = parseSpecReferences(SAMPLE_SPEC);
    expect(result.requirements).toContain('UserLogin');
    expect(result.requirements).toContain('UserRegistration');
  });

  it('should extract entity names', () => {
    const result = parseSpecReferences(SAMPLE_SPEC);
    expect(result.entities).toContain('User');
    expect(result.entities).toContain('Session');
  });

  it('should return empty arrays for spec with no references', () => {
    const spec = '# Simple Spec\n\n## Purpose\n\nMinimal content.';
    const result = parseSpecReferences(spec);
    expect(result.files).toEqual([]);
    expect(result.requirements).toEqual([]);
    expect(result.entities).toEqual([]);
  });

  it('should extract files from multi-line Implementation blocks', () => {
    const spec = `# Multi-line Spec

## Technical Notes

- **Implementation**:
  - \`src/auth/service.ts\`
  - \`src/auth/handler.ts\`
  - \`src/auth/utils.ts\`
- **Dependencies**: none
`;
    const result = parseSpecReferences(spec);
    expect(result.files).toContain('src/auth/service.ts');
    expect(result.files).toContain('src/auth/handler.ts');
    expect(result.files).toContain('src/auth/utils.ts');
  });

  it('should extract files from indented continuation lines', () => {
    const spec = `# Indented Spec

## Technical Notes

- **Implementation**: \`src/main.ts\`,
  \`src/helper.ts\`, \`src/config.ts\`
- **Dependencies**: none
`;
    const result = parseSpecReferences(spec);
    expect(result.files).toContain('src/main.ts');
    expect(result.files).toContain('src/helper.ts');
    expect(result.files).toContain('src/config.ts');
  });
});

// ============================================================================
// INFER DOMAIN FROM PATH TESTS
// ============================================================================

describe('inferDomainFromPath', () => {
  const knownDomains = ['auth', 'user', 'payment', 'cli'];

  it('should match direct directory name', () => {
    expect(inferDomainFromPath('src/auth/login.ts', knownDomains)).toBe('auth');
  });

  it('should match nested directory', () => {
    expect(inferDomainFromPath('src/core/user/model.ts', knownDomains)).toBe('user');
  });

  it('should match filename prefix', () => {
    expect(inferDomainFromPath('src/payment-processor.ts', knownDomains)).toBe('payment');
  });

  it('should return null for unmatched file', () => {
    expect(inferDomainFromPath('src/utils/helpers.ts', knownDomains)).toBeNull();
  });

  it('should be case-insensitive', () => {
    expect(inferDomainFromPath('src/Auth/Login.ts', knownDomains)).toBe('auth');
  });

  it('should handle root-level files', () => {
    expect(inferDomainFromPath('cli.ts', knownDomains)).toBe('cli');
  });

  it('should NOT match prefix without word boundary (auth vs authorize)', () => {
    expect(inferDomainFromPath('src/authorize.ts', knownDomains)).toBeNull();
  });

  it('should NOT match prefix without word boundary (auth vs authentication)', () => {
    expect(inferDomainFromPath('src/authentication.ts', knownDomains)).toBeNull();
  });

  it('should match prefix with hyphen word boundary', () => {
    expect(inferDomainFromPath('src/auth-handler.ts', knownDomains)).toBe('auth');
  });

  it('should match prefix with underscore word boundary', () => {
    expect(inferDomainFromPath('src/auth_service.ts', knownDomains)).toBe('auth');
  });

  it('should match prefix with dot word boundary', () => {
    expect(inferDomainFromPath('src/user.controller.ts', knownDomains)).toBe('user');
  });

  it('should prefer longer domain name over shorter match', () => {
    const domains = ['auth', 'authentication'];
    expect(inferDomainFromPath('src/authentication-service.ts', domains)).toBe('authentication');
  });
});

// ============================================================================
// BUILD SPEC MAP TESTS
// ============================================================================

describe('buildSpecMap', () => {
  let tempDir: string;
  let openspecPath: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
    openspecPath = join(tempDir, 'openspec');

    // Create spec directory structure
    await mkdir(join(openspecPath, 'specs', 'auth'), { recursive: true });
    await mkdir(join(openspecPath, 'specs', 'user'), { recursive: true });
    await mkdir(join(openspecPath, 'specs', 'overview'), { recursive: true });

    // Write spec files
    await writeFile(join(openspecPath, 'specs', 'auth', 'spec.md'), SAMPLE_SPEC);
    await writeFile(join(openspecPath, 'specs', 'user', 'spec.md'),
      `# User Specification\n\n> Source files: src/user/model.ts, src/user/service.ts\n\n## Purpose\n\nUser management.\n\n## Requirements\n\n### Requirement: UserCRUD\n\nThe system SHALL support user CRUD operations.\n`
    );
    await writeFile(join(openspecPath, 'specs', 'overview', 'spec.md'), OVERVIEW_SPEC);
  });

  afterEach(async () => {
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch { /* ignore */ }
  });

  it('should build domain mappings from spec files', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    expect(map.domainCount).toBeGreaterThanOrEqual(2);
    expect(map.byDomain.has('auth')).toBe(true);
    expect(map.byDomain.has('user')).toBe(true);
  });

  it('should include overview domain but not use it for file mapping', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    // Overview is in byDomain
    expect(map.byDomain.has('overview')).toBe(true);

    // But overview files should not be in byFile reverse map
    // (since overview is in the skipDomains set)
  });

  it('should build reverse file-to-domain mapping', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authDomains = map.byFile.get('src/auth/login.ts');
    expect(authDomains).toBeDefined();
    expect(authDomains).toContain('auth');
  });

  it('should combine header and body source files', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authMapping = map.byDomain.get('auth');
    expect(authMapping).toBeDefined();

    // Header files
    expect(authMapping!.declaredSourceFiles).toContain('src/auth/login.ts');
    expect(authMapping!.declaredSourceFiles).toContain('src/auth/register.ts');

    // Body files (from Technical Notes)
    expect(authMapping!.inferredSourceFiles).toContain('src/auth/middleware.ts');
    expect(authMapping!.inferredSourceFiles).toContain('src/auth/jwt.ts');

    // All files combined
    expect(authMapping!.allSourceFiles).toHaveLength(4);
  });

  it('should extract requirements and entities', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authMapping = map.byDomain.get('auth');
    expect(authMapping!.requirements).toContain('UserLogin');
    expect(authMapping!.requirements).toContain('UserRegistration');
    expect(authMapping!.entities).toContain('User');
    expect(authMapping!.entities).toContain('Session');
  });

  it('should handle missing specs directory gracefully', async () => {
    const map = await buildSpecMap({
      rootPath: tempDir,
      openspecPath: join(tempDir, 'nonexistent'),
    });

    expect(map.domainCount).toBe(0);
    expect(map.totalMappedFiles).toBe(0);
  });

  it('should count total mapped files correctly', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    // auth: 4 files + user: 2 files = 6 unique files in byFile
    expect(map.totalMappedFiles).toBe(6);
  });

  it('should produce correct relative spec paths for default openspec', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authMapping = map.byDomain.get('auth');
    expect(authMapping!.specPath).toBe(join('openspec', 'specs', 'auth', 'spec.md'));
  });

  it('should produce correct relative spec paths for custom openspec directory', async () => {
    // Create a custom openspec path
    const customPath = join(tempDir, 'my-specs');
    await mkdir(join(customPath, 'specs', 'billing'), { recursive: true });
    await writeFile(join(customPath, 'specs', 'billing', 'spec.md'),
      '# Billing Spec\n\n> Source files: src/billing/handler.ts\n\n## Purpose\n\nBilling.'
    );

    const map = await buildSpecMap({ rootPath: tempDir, openspecPath: customPath });

    const billingMapping = map.byDomain.get('billing');
    expect(billingMapping).toBeDefined();
    expect(billingMapping!.specPath).toBe(join('my-specs', 'specs', 'billing', 'spec.md'));
  });
});

// ============================================================================
// MATCH FILE TO DOMAINS TESTS
// ============================================================================

describe('matchFileToDomains', () => {
  let tempDir: string;
  let openspecPath: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
    openspecPath = join(tempDir, 'openspec');
    await mkdir(join(openspecPath, 'specs', 'auth'), { recursive: true });
    await writeFile(join(openspecPath, 'specs', 'auth', 'spec.md'), SAMPLE_SPEC);
  });

  afterEach(async () => {
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch { /* ignore */ }
  });

  it('should match files directly listed in specs', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });
    const domains = matchFileToDomains('src/auth/login.ts', map);
    expect(domains).toContain('auth');
  });

  it('should match files via directory inference', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });
    // This file isn't explicitly listed but is in the auth directory
    const domains = matchFileToDomains('src/auth/new-feature.ts', map);
    expect(domains).toContain('auth');
  });

  it('should return empty for completely unrelated files', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });
    const domains = matchFileToDomains('src/billing/invoice.ts', map);
    expect(domains).toEqual([]);
  });
});

// ============================================================================
// PARSE ADR RELATED TESTS
// ============================================================================

describe('parseADRRelated', () => {
  it('should extract domains and layers from Related section', () => {
    const content = `# ADR-001: Use JWT

## Status
accepted

## Related
**Domains**: auth, user
**Layers**: services, middleware
`;
    const result = parseADRRelated(content);
    expect(result.domains).toEqual(['auth', 'user']);
    expect(result.layers).toEqual(['services', 'middleware']);
  });

  it('should handle single domain and layer', () => {
    const content = `**Domains**: payment\n**Layers**: api`;
    const result = parseADRRelated(content);
    expect(result.domains).toEqual(['payment']);
    expect(result.layers).toEqual(['api']);
  });

  it('should return empty arrays when no Related section', () => {
    const content = `# ADR-002: Something\n\n## Status\naccepted\n\n## Context\nSome context.`;
    const result = parseADRRelated(content);
    expect(result.domains).toEqual([]);
    expect(result.layers).toEqual([]);
  });

  it('should handle extra whitespace in comma-separated values', () => {
    const content = `**Domains**: auth ,  user , payment\n**Layers**: api ,  services`;
    const result = parseADRRelated(content);
    expect(result.domains).toEqual(['auth', 'user', 'payment']);
    expect(result.layers).toEqual(['api', 'services']);
  });

  it('should handle domains without layers', () => {
    const content = `**Domains**: auth, user`;
    const result = parseADRRelated(content);
    expect(result.domains).toEqual(['auth', 'user']);
    expect(result.layers).toEqual([]);
  });

  it('should handle layers without domains', () => {
    const content = `**Layers**: middleware`;
    const result = parseADRRelated(content);
    expect(result.domains).toEqual([]);
    expect(result.layers).toEqual(['middleware']);
  });
});

// ============================================================================
// BUILD ADR MAP TESTS
// ============================================================================

describe('buildADRMap', () => {
  let tempDir: string;
  let openspecPath: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
    openspecPath = join(tempDir, 'openspec');
    await mkdir(join(openspecPath, 'decisions'), { recursive: true });
  });

  afterEach(async () => {
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch { /* ignore */ }
  });

  it('should build ADR map from decision files', async () => {
    await writeFile(join(openspecPath, 'decisions', 'adr-0001-use-jwt.md'), `# ADR-001: Use JWT for Authentication

## Status
accepted

## Related
**Domains**: auth, user
**Layers**: services
`);
    await writeFile(join(openspecPath, 'decisions', 'adr-0002-use-postgres.md'), `# ADR-002: Use PostgreSQL

## Status
accepted

## Related
**Domains**: payment
**Layers**: data
`);

    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).not.toBeNull();
    expect(result!.byId.size).toBe(2);
    expect(result!.byId.has('ADR-001')).toBe(true);
    expect(result!.byId.has('ADR-002')).toBe(true);

    // Check domain mapping
    expect(result!.byDomain.get('auth')).toContain('ADR-001');
    expect(result!.byDomain.get('user')).toContain('ADR-001');
    expect(result!.byDomain.get('payment')).toContain('ADR-002');
  });

  it('should skip superseded ADRs', async () => {
    await writeFile(join(openspecPath, 'decisions', 'adr-0001-old-approach.md'), `# ADR-001: Old Approach

## Status
superseded

## Related
**Domains**: auth
`);

    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).toBeNull(); // No valid ADRs â†’ null
  });

  it('should skip deprecated ADRs', async () => {
    await writeFile(join(openspecPath, 'decisions', 'adr-0001-deprecated.md'), `# ADR-001: Deprecated Approach

## Status
deprecated

## Related
**Domains**: auth
`);

    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).toBeNull();
  });

  it('should skip non-ADR files', async () => {
    await writeFile(join(openspecPath, 'decisions', 'index.md'), `# Decision Log\n\nOverview of decisions.`);
    await writeFile(join(openspecPath, 'decisions', 'adr-0001-valid.md'), `# ADR-001: Valid Decision

## Status
accepted

## Related
**Domains**: auth
`);

    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).not.toBeNull();
    expect(result!.byId.size).toBe(1);
    expect(result!.byId.has('ADR-001')).toBe(true);
  });

  it('should return null when no decisions directory exists', async () => {
    const result = await buildADRMap({
      rootPath: tempDir,
      openspecPath: join(tempDir, 'nonexistent'),
    });
    expect(result).toBeNull();
  });

  it('should return null when decisions directory is empty', async () => {
    // decisions dir exists but has no adr-*.md files
    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).toBeNull();
  });

  it('should store correct ADR metadata', async () => {
    await writeFile(join(openspecPath, 'decisions', 'adr-0003-caching.md'), `# ADR-003: Use Redis for Caching

## Status
accepted

## Related
**Domains**: cache, performance
**Layers**: infrastructure
`);

    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).not.toBeNull();

    const adr = result!.byId.get('ADR-003');
    expect(adr).toBeDefined();
    expect(adr!.title).toBe('Use Redis for Caching');
    expect(adr!.status).toBe('accepted');
    expect(adr!.relatedDomains).toEqual(['cache', 'performance']);
    expect(adr!.relatedLayers).toEqual(['infrastructure']);
    expect(adr!.adrPath).toContain('openspec/decisions/adr-0003-caching.md');
  });

  it('should build correct byDomain reverse map', async () => {
    await writeFile(join(openspecPath, 'decisions', 'adr-0001-jwt.md'), `# ADR-001: JWT

## Status
accepted

## Related
**Domains**: auth
`);
    await writeFile(join(openspecPath, 'decisions', 'adr-0002-oauth.md'), `# ADR-002: OAuth

## Status
accepted

## Related
**Domains**: auth, user
`);

    const result = await buildADRMap({ rootPath: tempDir, openspecPath });
    expect(result).not.toBeNull();

    // auth domain should reference both ADRs
    const authADRs = result!.byDomain.get('auth');
    expect(authADRs).toContain('ADR-001');
    expect(authADRs).toContain('ADR-002');

    // user domain should reference only ADR-002
    const userADRs = result!.byDomain.get('user');
    expect(userADRs).toContain('ADR-002');
    expect(userADRs).not.toContain('ADR-001');
  });
});
