/**
 * Tests for spec-mapper module
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  parseSpecHeader,
  parseSpecReferences,
  inferDomainFromPath,
  buildSpecMap,
  matchFileToDomains,
} from './spec-mapper.js';

// ============================================================================
// TEST HELPERS
// ============================================================================

async function createTempDir(): Promise<string> {
  const dir = join(tmpdir(), `spec-mapper-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  await mkdir(dir, { recursive: true });
  return dir;
}

const SAMPLE_SPEC = `# Auth Specification

> Generated by spec-gen v1.0.0 on 2025-01-30
> Source files: src/auth/login.ts, src/auth/register.ts

## Purpose

Manages authentication and authorization.

## Entities

### User

| Property | Type | Description |
|----------|------|-------------|
| email | string | User email |
| password | string | Hashed password |

### Session

| Property | Type | Description |
|----------|------|-------------|
| token | string | JWT token |

## Requirements

### Requirement: UserLogin

The system SHALL authenticate users via email and password.

#### Scenario: ValidLogin
- **GIVEN** valid credentials
- **WHEN** login is attempted
- **THEN** a session token is returned

### Requirement: UserRegistration

The system SHALL allow new user registration.

## Technical Notes

- **Implementation**: \`src/auth/middleware.ts\`, \`src/auth/jwt.ts\`
- **Dependencies**: user domain
`;

const OVERVIEW_SPEC = `# System Overview

> Generated by spec-gen v1.0.0 on 2025-01-30

## Purpose

System overview specification.

## Domains

- auth: Authentication and authorization
- user: User management
`;

// ============================================================================
// PARSE SPEC HEADER TESTS
// ============================================================================

describe('parseSpecHeader', () => {
  it('should extract source files from header', () => {
    const result = parseSpecHeader(SAMPLE_SPEC);
    expect(result.sourceFiles).toEqual(['src/auth/login.ts', 'src/auth/register.ts']);
  });

  it('should extract generated date', () => {
    const result = parseSpecHeader(SAMPLE_SPEC);
    expect(result.generatedDate).toBe('2025-01-30');
  });

  it('should handle spec with no source files header', () => {
    const spec = `# Test Spec\n\n## Purpose\n\nSome content.`;
    const result = parseSpecHeader(spec);
    expect(result.sourceFiles).toEqual([]);
    expect(result.generatedDate).toBeNull();
  });

  it('should handle backtick-wrapped filenames in source header', () => {
    const spec = '> Source files: `src/a.ts`, `src/b.ts`';
    const result = parseSpecHeader(spec);
    expect(result.sourceFiles).toEqual(['src/a.ts', 'src/b.ts']);
  });

  it('should handle singular "Source file" label', () => {
    const spec = '> Source file: src/single.ts';
    const result = parseSpecHeader(spec);
    expect(result.sourceFiles).toEqual(['src/single.ts']);
  });
});

// ============================================================================
// PARSE SPEC REFERENCES TESTS
// ============================================================================

describe('parseSpecReferences', () => {
  it('should extract implementation files from Technical Notes', () => {
    const result = parseSpecReferences(SAMPLE_SPEC);
    expect(result.files).toContain('src/auth/middleware.ts');
    expect(result.files).toContain('src/auth/jwt.ts');
  });

  it('should extract requirement names', () => {
    const result = parseSpecReferences(SAMPLE_SPEC);
    expect(result.requirements).toContain('UserLogin');
    expect(result.requirements).toContain('UserRegistration');
  });

  it('should extract entity names', () => {
    const result = parseSpecReferences(SAMPLE_SPEC);
    expect(result.entities).toContain('User');
    expect(result.entities).toContain('Session');
  });

  it('should return empty arrays for spec with no references', () => {
    const spec = '# Simple Spec\n\n## Purpose\n\nMinimal content.';
    const result = parseSpecReferences(spec);
    expect(result.files).toEqual([]);
    expect(result.requirements).toEqual([]);
    expect(result.entities).toEqual([]);
  });

  it('should extract files from multi-line Implementation blocks', () => {
    const spec = `# Multi-line Spec

## Technical Notes

- **Implementation**:
  - \`src/auth/service.ts\`
  - \`src/auth/handler.ts\`
  - \`src/auth/utils.ts\`
- **Dependencies**: none
`;
    const result = parseSpecReferences(spec);
    expect(result.files).toContain('src/auth/service.ts');
    expect(result.files).toContain('src/auth/handler.ts');
    expect(result.files).toContain('src/auth/utils.ts');
  });

  it('should extract files from indented continuation lines', () => {
    const spec = `# Indented Spec

## Technical Notes

- **Implementation**: \`src/main.ts\`,
  \`src/helper.ts\`, \`src/config.ts\`
- **Dependencies**: none
`;
    const result = parseSpecReferences(spec);
    expect(result.files).toContain('src/main.ts');
    expect(result.files).toContain('src/helper.ts');
    expect(result.files).toContain('src/config.ts');
  });
});

// ============================================================================
// INFER DOMAIN FROM PATH TESTS
// ============================================================================

describe('inferDomainFromPath', () => {
  const knownDomains = ['auth', 'user', 'payment', 'cli'];

  it('should match direct directory name', () => {
    expect(inferDomainFromPath('src/auth/login.ts', knownDomains)).toBe('auth');
  });

  it('should match nested directory', () => {
    expect(inferDomainFromPath('src/core/user/model.ts', knownDomains)).toBe('user');
  });

  it('should match filename prefix', () => {
    expect(inferDomainFromPath('src/payment-processor.ts', knownDomains)).toBe('payment');
  });

  it('should return null for unmatched file', () => {
    expect(inferDomainFromPath('src/utils/helpers.ts', knownDomains)).toBeNull();
  });

  it('should be case-insensitive', () => {
    expect(inferDomainFromPath('src/Auth/Login.ts', knownDomains)).toBe('auth');
  });

  it('should handle root-level files', () => {
    expect(inferDomainFromPath('cli.ts', knownDomains)).toBe('cli');
  });

  it('should NOT match prefix without word boundary (auth vs authorize)', () => {
    expect(inferDomainFromPath('src/authorize.ts', knownDomains)).toBeNull();
  });

  it('should NOT match prefix without word boundary (auth vs authentication)', () => {
    expect(inferDomainFromPath('src/authentication.ts', knownDomains)).toBeNull();
  });

  it('should match prefix with hyphen word boundary', () => {
    expect(inferDomainFromPath('src/auth-handler.ts', knownDomains)).toBe('auth');
  });

  it('should match prefix with underscore word boundary', () => {
    expect(inferDomainFromPath('src/auth_service.ts', knownDomains)).toBe('auth');
  });

  it('should match prefix with dot word boundary', () => {
    expect(inferDomainFromPath('src/user.controller.ts', knownDomains)).toBe('user');
  });

  it('should prefer longer domain name over shorter match', () => {
    const domains = ['auth', 'authentication'];
    expect(inferDomainFromPath('src/authentication-service.ts', domains)).toBe('authentication');
  });
});

// ============================================================================
// BUILD SPEC MAP TESTS
// ============================================================================

describe('buildSpecMap', () => {
  let tempDir: string;
  let openspecPath: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
    openspecPath = join(tempDir, 'openspec');

    // Create spec directory structure
    await mkdir(join(openspecPath, 'specs', 'auth'), { recursive: true });
    await mkdir(join(openspecPath, 'specs', 'user'), { recursive: true });
    await mkdir(join(openspecPath, 'specs', 'overview'), { recursive: true });

    // Write spec files
    await writeFile(join(openspecPath, 'specs', 'auth', 'spec.md'), SAMPLE_SPEC);
    await writeFile(join(openspecPath, 'specs', 'user', 'spec.md'),
      `# User Specification\n\n> Source files: src/user/model.ts, src/user/service.ts\n\n## Purpose\n\nUser management.\n\n## Requirements\n\n### Requirement: UserCRUD\n\nThe system SHALL support user CRUD operations.\n`
    );
    await writeFile(join(openspecPath, 'specs', 'overview', 'spec.md'), OVERVIEW_SPEC);
  });

  afterEach(async () => {
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch { /* ignore */ }
  });

  it('should build domain mappings from spec files', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    expect(map.domainCount).toBeGreaterThanOrEqual(2);
    expect(map.byDomain.has('auth')).toBe(true);
    expect(map.byDomain.has('user')).toBe(true);
  });

  it('should include overview domain but not use it for file mapping', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    // Overview is in byDomain
    expect(map.byDomain.has('overview')).toBe(true);

    // But overview files should not be in byFile reverse map
    // (since overview is in the skipDomains set)
  });

  it('should build reverse file-to-domain mapping', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authDomains = map.byFile.get('src/auth/login.ts');
    expect(authDomains).toBeDefined();
    expect(authDomains).toContain('auth');
  });

  it('should combine header and body source files', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authMapping = map.byDomain.get('auth');
    expect(authMapping).toBeDefined();

    // Header files
    expect(authMapping!.declaredSourceFiles).toContain('src/auth/login.ts');
    expect(authMapping!.declaredSourceFiles).toContain('src/auth/register.ts');

    // Body files (from Technical Notes)
    expect(authMapping!.inferredSourceFiles).toContain('src/auth/middleware.ts');
    expect(authMapping!.inferredSourceFiles).toContain('src/auth/jwt.ts');

    // All files combined
    expect(authMapping!.allSourceFiles).toHaveLength(4);
  });

  it('should extract requirements and entities', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authMapping = map.byDomain.get('auth');
    expect(authMapping!.requirements).toContain('UserLogin');
    expect(authMapping!.requirements).toContain('UserRegistration');
    expect(authMapping!.entities).toContain('User');
    expect(authMapping!.entities).toContain('Session');
  });

  it('should handle missing specs directory gracefully', async () => {
    const map = await buildSpecMap({
      rootPath: tempDir,
      openspecPath: join(tempDir, 'nonexistent'),
    });

    expect(map.domainCount).toBe(0);
    expect(map.totalMappedFiles).toBe(0);
  });

  it('should count total mapped files correctly', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    // auth: 4 files + user: 2 files = 6 unique files in byFile
    expect(map.totalMappedFiles).toBe(6);
  });

  it('should produce correct relative spec paths for default openspec', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });

    const authMapping = map.byDomain.get('auth');
    expect(authMapping!.specPath).toBe(join('openspec', 'specs', 'auth', 'spec.md'));
  });

  it('should produce correct relative spec paths for custom openspec directory', async () => {
    // Create a custom openspec path
    const customPath = join(tempDir, 'my-specs');
    await mkdir(join(customPath, 'specs', 'billing'), { recursive: true });
    await writeFile(join(customPath, 'specs', 'billing', 'spec.md'),
      '# Billing Spec\n\n> Source files: src/billing/handler.ts\n\n## Purpose\n\nBilling.'
    );

    const map = await buildSpecMap({ rootPath: tempDir, openspecPath: customPath });

    const billingMapping = map.byDomain.get('billing');
    expect(billingMapping).toBeDefined();
    expect(billingMapping!.specPath).toBe(join('my-specs', 'specs', 'billing', 'spec.md'));
  });
});

// ============================================================================
// MATCH FILE TO DOMAINS TESTS
// ============================================================================

describe('matchFileToDomains', () => {
  let tempDir: string;
  let openspecPath: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
    openspecPath = join(tempDir, 'openspec');
    await mkdir(join(openspecPath, 'specs', 'auth'), { recursive: true });
    await writeFile(join(openspecPath, 'specs', 'auth', 'spec.md'), SAMPLE_SPEC);
  });

  afterEach(async () => {
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch { /* ignore */ }
  });

  it('should match files directly listed in specs', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });
    const domains = matchFileToDomains('src/auth/login.ts', map);
    expect(domains).toContain('auth');
  });

  it('should match files via directory inference', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });
    // This file isn't explicitly listed but is in the auth directory
    const domains = matchFileToDomains('src/auth/new-feature.ts', map);
    expect(domains).toContain('auth');
  });

  it('should return empty for completely unrelated files', async () => {
    const map = await buildSpecMap({ rootPath: tempDir, openspecPath });
    const domains = matchFileToDomains('src/billing/invoice.ts', map);
    expect(domains).toEqual([]);
  });
});
