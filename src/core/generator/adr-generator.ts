/**
 * ADR Generator
 *
 * Converts enriched Architecture Decision Records from the LLM pipeline
 * into formatted markdown files following the standard ADR template.
 */

import type { EnrichedADR, ArchitectureSynthesis, PipelineResult } from './spec-pipeline.js';
import type { GeneratedSpec } from './openspec-format-generator.js';

// ============================================================================
// TYPES
// ============================================================================

export interface ADRGeneratorOptions {
  /** Version string for headers */
  version?: string;
  /** Include Mermaid architecture diagrams */
  includeMermaid?: boolean;
}

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Convert a title to a kebab-case slug for file naming.
 */
function titleToSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

// ============================================================================
// ADR GENERATOR
// ============================================================================

export class ADRGenerator {
  private options: Required<ADRGeneratorOptions>;

  constructor(options: ADRGeneratorOptions = {}) {
    this.options = {
      version: options.version ?? '1.0.0',
      includeMermaid: options.includeMermaid ?? true,
    };
  }

  /**
   * Generate all ADR specs from pipeline results.
   * Returns individual ADR files plus an index file.
   */
  generateADRs(result: PipelineResult): GeneratedSpec[] {
    if (!result.adrs || result.adrs.length === 0) return [];

    const specs: GeneratedSpec[] = [];

    for (const adr of result.adrs) {
      specs.push(this.generateSingleADR(adr, result.architecture));
    }

    specs.push(this.generateADRIndex(result.adrs));

    return specs;
  }

  /**
   * Generate a single ADR markdown file.
   */
  private generateSingleADR(adr: EnrichedADR, architecture: ArchitectureSynthesis): GeneratedSpec {
    const lines: string[] = [];
    const date = new Date().toISOString().split('T')[0];
    const slug = titleToSlug(adr.title);
    const adrNum = adr.id.replace(/[^0-9]/g, '').padStart(4, '0');

    // Header
    lines.push(`# ${adr.id}: ${adr.title}`);
    lines.push('');
    lines.push(`> Generated by spec-gen v${this.options.version} on ${date}`);
    lines.push('');

    // Status
    lines.push('## Status');
    lines.push('');
    lines.push(capitalize(adr.status));
    lines.push('');

    // Context
    lines.push('## Context');
    lines.push('');
    lines.push(adr.context);
    lines.push('');

    // Decision
    lines.push('## Decision');
    lines.push('');
    lines.push(adr.decision);
    lines.push('');

    // Consequences
    lines.push('## Consequences');
    lines.push('');
    if (adr.consequences.length > 0) {
      for (const consequence of adr.consequences) {
        lines.push(`- ${consequence}`);
      }
    } else {
      lines.push('No consequences identified.');
    }
    lines.push('');

    // Alternatives Considered
    if (adr.alternatives.length > 0) {
      lines.push('## Alternatives Considered');
      lines.push('');
      for (const alt of adr.alternatives) {
        lines.push(`- ${alt}`);
      }
      lines.push('');
    }

    // Architecture Impact (Mermaid diagram)
    if (this.options.includeMermaid && adr.relatedLayers.length > 0 && architecture.layerMap.length > 0) {
      lines.push('## Architecture Impact');
      lines.push('');
      lines.push('```mermaid');
      lines.push('graph TB');

      // Filter to affected layers
      const affectedLayers = architecture.layerMap.filter(
        l => adr.relatedLayers.some(rl => l.name.toLowerCase().includes(rl.toLowerCase()))
      );

      // Fall back to all layers if filter matched nothing
      const layers = affectedLayers.length > 0 ? affectedLayers : architecture.layerMap;

      for (let i = 0; i < layers.length; i++) {
        const layer = layers[i];
        const layerId = layer.name.replace(/\s+/g, '');
        const isAffected = affectedLayers.length > 0;
        lines.push(`    ${layerId}["${layer.name}"]`);

        if (i < layers.length - 1) {
          const nextLayerId = layers[i + 1].name.replace(/\s+/g, '');
          lines.push(`    ${layerId} --> ${nextLayerId}`);
        }

        if (isAffected) {
          lines.push(`    style ${layerId} fill:#f9f,stroke:#333`);
        }
      }

      lines.push('```');
      lines.push('');
    }

    // Related
    lines.push('## Related');
    lines.push('');
    if (adr.relatedLayers.length > 0) {
      lines.push(`- **Layers**: ${adr.relatedLayers.join(', ')}`);
    }
    if (adr.relatedDomains.length > 0) {
      lines.push(`- **Domains**: ${adr.relatedDomains.join(', ')}`);
    }
    if (adr.relatedLayers.length === 0 && adr.relatedDomains.length === 0) {
      lines.push('No specific layers or domains identified.');
    }
    lines.push('');

    return {
      path: `openspec/decisions/adr-${adrNum}-${slug}.md`,
      content: lines.join('\n'),
      domain: 'decisions',
      type: 'adr',
    };
  }

  /**
   * Generate the ADR index file with a table of all decisions.
   */
  private generateADRIndex(adrs: EnrichedADR[]): GeneratedSpec {
    const lines: string[] = [];
    const date = new Date().toISOString().split('T')[0];

    lines.push('# Architecture Decision Records');
    lines.push('');
    lines.push(`> Generated by spec-gen v${this.options.version} on ${date}`);
    lines.push('');
    lines.push('This directory contains Architecture Decision Records (ADRs) that document');
    lines.push('the key architectural decisions observed in this codebase.');
    lines.push('');
    lines.push('## Decisions');
    lines.push('');
    lines.push('| ID | Decision | Status | Layers |');
    lines.push('|----|----------|--------|--------|');

    for (const adr of adrs) {
      const adrNum = adr.id.replace(/[^0-9]/g, '').padStart(4, '0');
      const slug = titleToSlug(adr.title);
      const fileName = `adr-${adrNum}-${slug}.md`;
      const layers = adr.relatedLayers.join(', ') || '-';
      lines.push(`| [${adr.id}](./${fileName}) | ${adr.title} | ${capitalize(adr.status)} | ${layers} |`);
    }

    lines.push('');
    lines.push('## About ADRs');
    lines.push('');
    lines.push('Architecture Decision Records capture the *why* behind architectural choices.');
    lines.push('Each ADR documents the context, decision, and consequences of a significant');
    lines.push('technical decision. Unlike specifications (which describe *what* the system does),');
    lines.push('ADRs explain *why* it was built that way.');
    lines.push('');
    lines.push('ADRs are **immutable records**. When a decision is reversed, the original ADR');
    lines.push('is marked as "Superseded" and a new ADR is created referencing it.');
    lines.push('');

    return {
      path: 'openspec/decisions/index.md',
      content: lines.join('\n'),
      domain: 'decisions',
      type: 'adr',
    };
  }
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
