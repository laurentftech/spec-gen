/**
 * OpenSpec Compatibility Layer Tests
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile, readFile } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  OpenSpecValidator,
  OpenSpecConfigManager,
  buildDetectedContext,
  normalizeDomainName,
  isValidDomainName,
  matchExistingDomains,
  validateFullSpec,
  validateSpecsDirectory,
  createOpenSpecCompat,
  type OpenSpecConfig,
  type SpecGenMetadata,
} from './openspec-compat.js';
import type { ProjectSurveyResult } from './spec-pipeline.js';

// ============================================================================
// TEST HELPERS
// ============================================================================

async function createTempDir(): Promise<string> {
  const dir = join(tmpdir(), `openspec-compat-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  await mkdir(dir, { recursive: true });
  return dir;
}

function createMockSurvey(): ProjectSurveyResult {
  return {
    projectCategory: 'web-backend',
    primaryLanguage: 'TypeScript',
    frameworks: ['Express', 'TypeORM', 'tsyringe'],
    architecturePattern: 'layered',
    domainSummary: 'A user management API service',
    suggestedDomains: ['user', 'auth', 'api'],
    confidence: 0.85,
    schemaFiles: [],
    serviceFiles: [],
    apiFiles: [],
  };
}

// ============================================================================
// VALIDATOR TESTS
// ============================================================================

describe('OpenSpecValidator', () => {
  let validator: OpenSpecValidator;

  beforeEach(() => {
    validator = new OpenSpecValidator();
  });

  describe('validateSpecStructure', () => {
    it('should validate a valid spec', () => {
      const validSpec = `# User Specification

> Generated by spec-gen

## Purpose

Manages user data.

## Requirements

### Requirement: UserValidation

The system SHALL validate user data.

#### Scenario: ValidUser
- **GIVEN** valid user data
- **WHEN** validation is performed
- **THEN** validation succeeds
`;

      const result = validator.validateSpecStructure(validSpec);

      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect missing title', () => {
      const spec = `## Purpose

Some content`;

      const result = validator.validateSpecStructure(spec);

      expect(result.errors).toContain('Missing title (# heading)');
    });

    it('should warn on missing Purpose section', () => {
      const spec = `# Spec

## Requirements

Content here`;

      const result = validator.validateSpecStructure(spec);

      expect(result.warnings.some(w => w.includes('Purpose'))).toBe(true);
    });

    it('should detect delta markers', () => {
      const spec = `# Spec

## Purpose

[ADDED] New purpose

## Requirements
`;

      const result = validator.validateSpecStructure(spec);

      expect(result.errors.some(e => e.includes('delta markers'))).toBe(true);
    });

    it('should detect skipped heading levels', () => {
      const spec = `# Title

#### Skipped to level 4

Content`;

      const result = validator.validateSpecStructure(spec);

      expect(result.warnings.some(w => w.includes('Heading level jumped'))).toBe(true);
    });

    it('should accept specs with Domains instead of Requirements', () => {
      const spec = `# System Overview

## Purpose

System overview.

## Domains

- User
- Auth
`;

      const result = validator.validateSpecStructure(spec);

      expect(result.valid).toBe(true);
    });

    it('should accept specs with Key Capabilities', () => {
      const spec = `# System Overview

## Purpose

Overview.

## Key Capabilities

### Requirement: Cap1
`;

      const result = validator.validateSpecStructure(spec);

      expect(result.valid).toBe(true);
    });
  });

  describe('validateRequirementFormat', () => {
    it('should validate requirement with RFC 2119 keywords', () => {
      const requirement = 'The system SHALL validate all user input.';

      const result = validator.validateRequirementFormat(requirement);

      expect(result.warnings.every(w => !w.includes('RFC 2119'))).toBe(true);
    });

    it('should warn on missing RFC 2119 keywords', () => {
      const requirement = 'The system validates user input.';

      const result = validator.validateRequirementFormat(requirement);

      expect(result.warnings.some(w => w.includes('RFC 2119'))).toBe(true);
    });

    it('should accept all RFC 2119 keywords', () => {
      const keywords = ['SHALL', 'MUST', 'SHOULD', 'MAY', 'SHALL NOT', 'MUST NOT'];

      for (const keyword of keywords) {
        const requirement = `The system ${keyword} do something.`;
        const result = validator.validateRequirementFormat(requirement);
        expect(result.warnings.filter(w => w.includes('RFC 2119'))).toHaveLength(0);
      }
    });

    it('should warn on very short requirements', () => {
      const requirement = 'System works.';

      const result = validator.validateRequirementFormat(requirement);

      expect(result.warnings.some(w => w.includes('brief'))).toBe(true);
    });
  });

  describe('validateScenarioFormat', () => {
    it('should validate complete scenario', () => {
      const scenario = `#### Scenario: ValidUser
- **GIVEN** valid user data
- **WHEN** validation is performed
- **THEN** validation succeeds`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should error on missing GIVEN', () => {
      const scenario = `#### Scenario: Test
- **WHEN** action
- **THEN** result`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.errors.some(e => e.includes('GIVEN'))).toBe(true);
    });

    it('should error on missing WHEN', () => {
      const scenario = `#### Scenario: Test
- **GIVEN** state
- **THEN** result`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.errors.some(e => e.includes('WHEN'))).toBe(true);
    });

    it('should error on missing THEN', () => {
      const scenario = `#### Scenario: Test
- **GIVEN** state
- **WHEN** action`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.errors.some(e => e.includes('THEN'))).toBe(true);
    });

    it('should error on wrong heading level', () => {
      const scenario = `### Scenario: Test
- **GIVEN** state
- **WHEN** action
- **THEN** result`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.errors.some(e => e.includes('4 hashtags'))).toBe(true);
    });

    it('should warn on unformatted AND', () => {
      const scenario = `#### Scenario: Test
- **GIVEN** state
- **WHEN** action
- **THEN** result
- AND more`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.warnings.some(w => w.includes('AND'))).toBe(true);
    });

    it('should accept properly formatted AND', () => {
      const scenario = `#### Scenario: Test
- **GIVEN** state
- **WHEN** action
- **THEN** result
- **AND** more`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.valid).toBe(true);
    });

    it('should error on wrong order (WHEN before GIVEN)', () => {
      const scenario = `#### Scenario: Test
- **WHEN** action
- **GIVEN** state
- **THEN** result`;

      const result = validator.validateScenarioFormat(scenario);

      expect(result.errors.some(e => e.includes('GIVEN must come before WHEN'))).toBe(true);
    });
  });

  describe('validateConfigYaml', () => {
    it('should validate valid config', () => {
      const config = {
        schema: 'spec-driven',
        context: 'Project context here',
        rules: {
          proposal: ['rule1'],
          specs: ['rule2'],
        },
      };

      const result = validator.validateConfigYaml(config);

      expect(result.valid).toBe(true);
    });

    it('should error on non-object config', () => {
      const result = validator.validateConfigYaml('not an object');

      expect(result.errors).toContain('Config must be an object');
    });

    it('should error on invalid schema type', () => {
      const config = { schema: 123 };

      const result = validator.validateConfigYaml(config);

      expect(result.errors.some(e => e.includes('schema must be a string'))).toBe(true);
    });

    it('should error on invalid rules type', () => {
      const config = { rules: 'not an object' };

      const result = validator.validateConfigYaml(config);

      expect(result.errors.some(e => e.includes('rules must be an object'))).toBe(true);
    });

    it('should warn on unknown rule keys', () => {
      const config = { rules: { unknown: [] } };

      const result = validator.validateConfigYaml(config);

      expect(result.warnings.some(w => w.includes('Unknown rule key'))).toBe(true);
    });

    it('should validate spec-gen metadata', () => {
      const config = {
        'spec-gen': {
          version: '1.0.0',
          generatedAt: '2024-01-01',
          domains: ['user', 'auth'],
          confidence: 0.85,
        },
      };

      const result = validator.validateConfigYaml(config);

      expect(result.valid).toBe(true);
    });
  });
});

// ============================================================================
// CONFIG MANAGER TESTS
// ============================================================================

describe('OpenSpecConfigManager', () => {
  let tempDir: string;
  let manager: OpenSpecConfigManager;

  beforeEach(async () => {
    tempDir = await createTempDir();
    manager = new OpenSpecConfigManager(tempDir);
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  describe('isInitialized', () => {
    it('should return false when openspec dir does not exist', async () => {
      const result = await manager.isInitialized();
      expect(result).toBe(false);
    });

    it('should return true when openspec dir exists', async () => {
      await mkdir(join(tempDir, 'openspec'), { recursive: true });

      const result = await manager.isInitialized();

      expect(result).toBe(true);
    });
  });

  describe('hasConfig', () => {
    it('should return false when config.yaml does not exist', async () => {
      const result = await manager.hasConfig();
      expect(result).toBe(false);
    });

    it('should return true when config.yaml exists', async () => {
      await mkdir(join(tempDir, 'openspec'), { recursive: true });
      await writeFile(join(tempDir, 'openspec', 'config.yaml'), 'schema: spec-driven');

      const result = await manager.hasConfig();

      expect(result).toBe(true);
    });
  });

  describe('readConfig', () => {
    it('should return null when config does not exist', async () => {
      const result = await manager.readConfig();
      expect(result).toBeNull();
    });

    it('should parse existing config', async () => {
      await mkdir(join(tempDir, 'openspec'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec', 'config.yaml'),
        'schema: spec-driven\ncontext: Test context'
      );

      const result = await manager.readConfig();

      expect(result).toEqual({
        schema: 'spec-driven',
        context: 'Test context',
      });
    });
  });

  describe('writeConfig', () => {
    it('should create directory and write config', async () => {
      const config: OpenSpecConfig = {
        schema: 'spec-driven',
        context: 'Test context',
      };

      await manager.writeConfig(config);

      const content = await readFile(join(tempDir, 'openspec', 'config.yaml'), 'utf-8');
      expect(content).toContain('schema: spec-driven');
      expect(content).toContain('context: Test context');
    });
  });

  describe('updateWithSpecGenMetadata', () => {
    it('should create new config with metadata', async () => {
      const metadata: SpecGenMetadata = {
        version: '1.0.0',
        generatedAt: '2024-01-01T00:00:00Z',
        domains: ['user', 'auth'],
        confidence: 0.85,
      };

      await manager.updateWithSpecGenMetadata(metadata);

      const config = await manager.readConfig();
      expect(config?.['spec-gen']).toEqual(metadata);
      expect(config?.schema).toBe('spec-driven');
    });

    it('should preserve existing config when updating', async () => {
      await mkdir(join(tempDir, 'openspec'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec', 'config.yaml'),
        'schema: custom\ncontext: User context\nrules:\n  specs:\n    - rule1'
      );

      const metadata: SpecGenMetadata = {
        version: '1.0.0',
        generatedAt: '2024-01-01T00:00:00Z',
        domains: ['user'],
        confidence: 0.9,
      };

      await manager.updateWithSpecGenMetadata(metadata);

      const config = await manager.readConfig();
      expect(config?.schema).toBe('custom');
      expect(config?.rules?.specs).toEqual(['rule1']);
      expect(config?.['spec-gen']).toEqual(metadata);
    });

    it('should append detected context', async () => {
      await mkdir(join(tempDir, 'openspec'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec', 'config.yaml'),
        'schema: spec-driven\ncontext: User provided context'
      );

      const metadata: SpecGenMetadata = {
        version: '1.0.0',
        generatedAt: '2024-01-01',
        domains: ['user'],
        confidence: 0.8,
      };

      const detectedContext = {
        techStack: 'TypeScript, Express',
        architecture: 'Layered',
        domains: ['user', 'auth'],
        patterns: ['Repository pattern'],
      };

      await manager.updateWithSpecGenMetadata(metadata, detectedContext, {
        preserveUserContext: true,
        appendDetectedInfo: true,
        version: '1.0.0',
      });

      const config = await manager.readConfig();
      expect(config?.context).toContain('User provided context');
      expect(config?.context).toContain('Auto-detected by spec-gen');
      expect(config?.context).toContain('TypeScript, Express');
    });
  });

  describe('getExistingDomains', () => {
    it('should return empty array when specs dir does not exist', async () => {
      const domains = await manager.getExistingDomains();
      expect(domains).toEqual([]);
    });

    it('should return domain directories', async () => {
      const specsDir = join(tempDir, 'openspec', 'specs');
      await mkdir(join(specsDir, 'user'), { recursive: true });
      await mkdir(join(specsDir, 'auth'), { recursive: true });
      await mkdir(join(specsDir, 'overview'), { recursive: true });

      const domains = await manager.getExistingDomains();

      expect(domains).toContain('user');
      expect(domains).toContain('auth');
      expect(domains).not.toContain('overview'); // Filtered out
    });
  });
});

// ============================================================================
// CONTEXT BUILDING TESTS
// ============================================================================

describe('buildDetectedContext', () => {
  it('should build context from survey', () => {
    const survey = createMockSurvey();

    const context = buildDetectedContext(survey);

    expect(context.techStack).toContain('TypeScript');
    expect(context.techStack).toContain('Express');
    expect(context.architecture).toContain('Layered');
    expect(context.domains).toEqual(['user', 'auth', 'api']);
  });

  it('should detect repository pattern', () => {
    const survey = createMockSurvey();
    survey.frameworks = ['TypeORM'];

    const context = buildDetectedContext(survey);

    expect(context.patterns).toContain('Repository pattern');
  });

  it('should detect dependency injection', () => {
    const survey = createMockSurvey();
    survey.frameworks = ['tsyringe'];

    const context = buildDetectedContext(survey);

    expect(context.patterns).toContain('Dependency injection');
  });

  it('should detect middleware pattern', () => {
    const survey = createMockSurvey();
    survey.frameworks = ['Express'];

    const context = buildDetectedContext(survey);

    expect(context.patterns).toContain('Middleware pipeline');
  });

  it('should detect component-based UI', () => {
    const survey = createMockSurvey();
    survey.frameworks = ['React'];

    const context = buildDetectedContext(survey);

    expect(context.patterns).toContain('Component-based UI');
  });
});

// ============================================================================
// DOMAIN NAMING TESTS
// ============================================================================

describe('normalizeDomainName', () => {
  it('should convert to lowercase', () => {
    expect(normalizeDomainName('User')).toBe('user');
    expect(normalizeDomainName('AUTH')).toBe('auth');
  });

  it('should convert spaces to hyphens', () => {
    expect(normalizeDomainName('user profile')).toBe('user-profile');
  });

  it('should convert underscores to hyphens', () => {
    expect(normalizeDomainName('user_profile')).toBe('user-profile');
  });

  it('should remove leading/trailing hyphens', () => {
    expect(normalizeDomainName('-user-')).toBe('user');
  });

  it('should collapse multiple hyphens', () => {
    expect(normalizeDomainName('user--profile')).toBe('user-profile');
  });

  it('should remove special characters', () => {
    expect(normalizeDomainName('user@profile!')).toBe('user-profile');
  });
});

describe('isValidDomainName', () => {
  it('should accept valid domain names', () => {
    expect(isValidDomainName('user')).toBe(true);
    expect(isValidDomainName('user-profile')).toBe(true);
    expect(isValidDomainName('auth')).toBe(true);
    expect(isValidDomainName('api')).toBe(true);
  });

  it('should reject uppercase', () => {
    expect(isValidDomainName('User')).toBe(false);
  });

  it('should reject generic names', () => {
    expect(isValidDomainName('misc')).toBe(false);
    expect(isValidDomainName('other')).toBe(false);
    expect(isValidDomainName('utils')).toBe(false);
    expect(isValidDomainName('common')).toBe(false);
    expect(isValidDomainName('helpers')).toBe(false);
  });

  it('should reject names starting with hyphen', () => {
    expect(isValidDomainName('-user')).toBe(false);
  });

  it('should reject names ending with hyphen', () => {
    expect(isValidDomainName('user-')).toBe(false);
  });

  it('should reject names starting with number', () => {
    expect(isValidDomainName('1user')).toBe(false);
  });
});

describe('matchExistingDomains', () => {
  it('should find exact matches', () => {
    const suggested = ['user', 'auth'];
    const existing = ['user', 'auth', 'api'];

    const matches = matchExistingDomains(suggested, existing);

    expect(matches.get('user')).toBe('user');
    expect(matches.get('auth')).toBe('auth');
  });

  it('should find partial matches (suggested is substring)', () => {
    const suggested = ['user'];
    const existing = ['user-profile', 'auth'];

    const matches = matchExistingDomains(suggested, existing);

    expect(matches.get('user')).toBe('user-profile');
  });

  it('should find partial matches (existing is substring)', () => {
    const suggested = ['user-management'];
    const existing = ['user', 'auth'];

    const matches = matchExistingDomains(suggested, existing);

    expect(matches.get('user-management')).toBe('user');
  });

  it('should return empty map for no matches', () => {
    const suggested = ['payment'];
    const existing = ['user', 'auth'];

    const matches = matchExistingDomains(suggested, existing);

    expect(matches.size).toBe(0);
  });
});

// ============================================================================
// FULL SPEC VALIDATION TESTS
// ============================================================================

describe('validateFullSpec', () => {
  it('should validate complete valid spec', () => {
    const spec = `# User Specification

> Generated by spec-gen

## Purpose

Manages user data and authentication.

## Requirements

### Requirement: UserValidation

The system SHALL validate all user input before processing.

#### Scenario: ValidInput
- **GIVEN** valid user data is submitted
- **WHEN** the system validates the input
- **THEN** validation succeeds

### Requirement: UserCreation

The system MUST create users with unique emails.

#### Scenario: CreateUser
- **GIVEN** a new user with unique email
- **WHEN** the user is created
- **THEN** the user is stored in the database
- **AND** a confirmation email is sent
`;

    const result = validateFullSpec(spec);

    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  it('should collect errors from all requirements', () => {
    const spec = `# Spec

## Purpose

Purpose here.

## Requirements

### Requirement: Bad1

No RFC keywords here at all.

### Requirement: Bad2

Missing RFC keywords too.
`;

    const result = validateFullSpec(spec);

    // Should have warnings for both requirements missing RFC 2119 keywords
    expect(result.warnings.filter(w => w.includes('RFC 2119')).length).toBe(2);
  });

  it('should collect errors from all scenarios', () => {
    const spec = `# Spec

## Purpose

Purpose.

## Requirements

### Requirement: Test

The system SHALL work.

#### Scenario: Bad1
- **GIVEN** state
- **WHEN** action

#### Scenario: Bad2
- **GIVEN** state
- **THEN** result
`;

    const result = validateFullSpec(spec);

    expect(result.errors.filter(e => e.includes('THEN')).length).toBeGreaterThan(0);
    expect(result.errors.filter(e => e.includes('WHEN')).length).toBeGreaterThan(0);
  });
});

describe('validateSpecsDirectory', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('should validate all specs in directory', async () => {
    const specsDir = join(tempDir, 'specs');
    await mkdir(join(specsDir, 'user'), { recursive: true });
    await mkdir(join(specsDir, 'auth'), { recursive: true });

    await writeFile(
      join(specsDir, 'user', 'spec.md'),
      `# User Specification

## Purpose

User management.

## Requirements

### Requirement: UserAuth

The system SHALL authenticate users.

#### Scenario: Login
- **GIVEN** valid credentials
- **WHEN** login is attempted
- **THEN** authentication succeeds
`
    );

    await writeFile(
      join(specsDir, 'auth', 'spec.md'),
      `# Auth Specification

## Purpose

Authentication.

## Requirements

### Requirement: TokenGen

The system SHALL generate tokens.

#### Scenario: GenerateToken
- **GIVEN** valid session
- **WHEN** token is requested
- **THEN** token is generated
`
    );

    const { valid, results } = await validateSpecsDirectory(specsDir);

    expect(valid).toBe(true);
    expect(results.size).toBe(2);
    expect(results.get('user')?.valid).toBe(true);
    expect(results.get('auth')?.valid).toBe(true);
  });

  it('should report missing spec.md', async () => {
    const specsDir = join(tempDir, 'specs');
    await mkdir(join(specsDir, 'empty'), { recursive: true });

    const { valid, results } = await validateSpecsDirectory(specsDir);

    expect(valid).toBe(false);
    expect(results.get('empty')?.errors).toContain('spec.md not found');
  });

  it('should handle missing specs directory', async () => {
    const { valid, results } = await validateSpecsDirectory(join(tempDir, 'nonexistent'));

    expect(valid).toBe(false);
    expect(results.get('specs')?.errors).toContain('specs directory not found');
  });
});

// ============================================================================
// CONVENIENCE FUNCTION TESTS
// ============================================================================

describe('createOpenSpecCompat', () => {
  it('should create validator and config manager', () => {
    const compat = createOpenSpecCompat('/project');

    expect(compat.validator).toBeInstanceOf(OpenSpecValidator);
    expect(compat.configManager).toBeInstanceOf(OpenSpecConfigManager);
  });
});
