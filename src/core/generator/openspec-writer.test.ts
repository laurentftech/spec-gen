/**
 * OpenSpec Writer Tests
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, writeFile, readFile, readdir, access } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  OpenSpecWriter,
  writeOpenSpecs,
  initializeOpenSpec,
  type WriteMode,
  type GenerationReport,
} from './openspec-writer.js';
import type { GeneratedSpec } from './openspec-format-generator.js';
import type { ProjectSurveyResult } from './spec-pipeline.js';

// ============================================================================
// TEST HELPERS
// ============================================================================

async function createTempDir(): Promise<string> {
  const dir = join(tmpdir(), `openspec-writer-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  await mkdir(dir, { recursive: true });
  return dir;
}

async function fileExists(path: string): Promise<boolean> {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

function createMockSurvey(): ProjectSurveyResult {
  return {
    projectCategory: 'web-backend',
    primaryLanguage: 'TypeScript',
    frameworks: ['Express', 'TypeORM'],
    architecturePattern: 'layered',
    domainSummary: 'A user management API service',
    suggestedDomains: ['user', 'auth'],
    confidence: 0.85,
    schemaFiles: [],
    serviceFiles: [],
    apiFiles: [],
  };
}

function createMockSpecs(): GeneratedSpec[] {
  return [
    {
      path: 'openspec/specs/overview/spec.md',
      content: `# System Overview

> Generated by spec-gen v1.0.0 on 2024-01-01
> Confidence: 85%

## Purpose

A user management API service.

## Domains

| Domain | Description | Spec |
|--------|-------------|------|
| User | Manages user entities | [spec.md](../user/spec.md) |
`,
      domain: 'overview',
      type: 'overview',
    },
    {
      path: 'openspec/specs/user/spec.md',
      content: `# User Specification

> Generated by spec-gen v1.0.0 on 2024-01-01

## Purpose

Manages user data and authentication.

## Requirements

### Requirement: UserValidation

The system SHALL validate all user input.

#### Scenario: ValidUser
- **GIVEN** valid user data
- **WHEN** validation is performed
- **THEN** validation succeeds
`,
      domain: 'user',
      type: 'domain',
    },
    {
      path: 'openspec/specs/architecture/spec.md',
      content: `# Architecture Specification

> Generated by spec-gen v1.0.0 on 2024-01-01

## Purpose

System architecture documentation.

## Architecture Style

Layered architecture.
`,
      domain: 'architecture',
      type: 'architecture',
    },
  ];
}

// ============================================================================
// TESTS
// ============================================================================

describe('OpenSpecWriter', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  describe('initialize', () => {
    it('should create OpenSpec directory structure', async () => {
      const writer = new OpenSpecWriter({ rootPath: tempDir });

      await writer.initialize();

      expect(await fileExists(join(tempDir, 'openspec', 'specs'))).toBe(true);
      expect(await fileExists(join(tempDir, 'openspec', 'changes', 'archive'))).toBe(true);
      expect(await fileExists(join(tempDir, '.spec-gen', 'analysis'))).toBe(true);
      expect(await fileExists(join(tempDir, '.spec-gen', 'backups'))).toBe(true);
      expect(await fileExists(join(tempDir, '.spec-gen', 'outputs'))).toBe(true);
      expect(await fileExists(join(tempDir, '.spec-gen', 'logs'))).toBe(true);
    });
  });

  describe('writeSpecs', () => {
    it('should write all specs to correct paths', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        version: '1.0.0',
        updateConfig: false,
      });
      const specs = createMockSpecs();
      const survey = createMockSurvey();

      const report = await writer.writeSpecs(specs, survey);

      expect(report.filesWritten).toHaveLength(3);
      expect(await fileExists(join(tempDir, 'openspec/specs/overview/spec.md'))).toBe(true);
      expect(await fileExists(join(tempDir, 'openspec/specs/user/spec.md'))).toBe(true);
      expect(await fileExists(join(tempDir, 'openspec/specs/architecture/spec.md'))).toBe(true);
    });

    it('should write correct content', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        updateConfig: false,
      });
      const specs = createMockSpecs();
      const survey = createMockSurvey();

      await writer.writeSpecs(specs, survey);

      const userSpec = await readFile(join(tempDir, 'openspec/specs/user/spec.md'), 'utf-8');
      expect(userSpec).toContain('# User Specification');
      expect(userSpec).toContain('## Purpose');
      expect(userSpec).toContain('### Requirement: UserValidation');
    });

    it('should save generation report', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        updateConfig: false,
      });
      const specs = createMockSpecs();
      const survey = createMockSurvey();

      await writer.writeSpecs(specs, survey);

      const reportPath = join(tempDir, '.spec-gen/outputs/generation-report.json');
      expect(await fileExists(reportPath)).toBe(true);

      const report = JSON.parse(await readFile(reportPath, 'utf-8'));
      expect(report.filesWritten).toHaveLength(3);
      expect(report.nextSteps.length).toBeGreaterThan(0);
    });

    it('should include timestamp in report', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      expect(report.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T/);
    });
  });

  describe('Write Mode: replace (default)', () => {
    it('should backup and replace existing files', async () => {
      // Create existing spec
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/specs/user/spec.md'),
        '# Old User Spec\n\nOriginal content'
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        writeMode: 'replace',
        createBackups: true,
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      // New content should be written
      const newContent = await readFile(join(tempDir, 'openspec/specs/user/spec.md'), 'utf-8');
      expect(newContent).toContain('# User Specification');
      expect(newContent).not.toContain('Original content');

      // Backup should exist
      expect(report.filesBackedUp.length).toBeGreaterThan(0);
      const backupDir = join(tempDir, '.spec-gen/backups');
      const backupDirs = await readdir(backupDir);
      expect(backupDirs.length).toBeGreaterThan(0);
    });

    it('should not backup when createBackups is false', async () => {
      // Create existing spec
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/specs/user/spec.md'),
        '# Old User Spec'
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        writeMode: 'replace',
        createBackups: false,
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      expect(report.filesBackedUp).toHaveLength(0);
    });
  });

  describe('Write Mode: skip', () => {
    it('should skip existing files', async () => {
      // Create existing spec
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/specs/user/spec.md'),
        '# Old User Spec\n\nPreserved content'
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        writeMode: 'skip',
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      // Original content should be preserved
      const content = await readFile(join(tempDir, 'openspec/specs/user/spec.md'), 'utf-8');
      expect(content).toContain('Preserved content');

      // Should be in skipped list
      expect(report.filesSkipped).toContain('openspec/specs/user/spec.md');
    });

    it('should write non-existing files', async () => {
      // Create existing spec for user only
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/specs/user/spec.md'),
        '# Old User Spec'
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        writeMode: 'skip',
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      // Overview should be written (didn't exist)
      expect(report.filesWritten).toContain('openspec/specs/overview/spec.md');
      expect(await fileExists(join(tempDir, 'openspec/specs/overview/spec.md'))).toBe(true);
    });
  });

  describe('Write Mode: merge', () => {
    it('should append generated section to existing spec', async () => {
      // Create existing spec with human content
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/specs/user/spec.md'),
        `# User Specification

## Purpose

Human-written purpose that should be preserved.

## Requirements

### Requirement: ManualRequirement

The system SHALL do something manually documented.
`
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        writeMode: 'merge',
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      // Check merged content
      const content = await readFile(join(tempDir, 'openspec/specs/user/spec.md'), 'utf-8');
      expect(content).toContain('Human-written purpose');
      expect(content).toContain('ManualRequirement');
      expect(content).toContain('## Generated Analysis');

      expect(report.filesMerged).toContain('openspec/specs/user/spec.md');
    });

    it('should replace existing generated section on re-merge', async () => {
      // Create spec with existing generated section
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/specs/user/spec.md'),
        `# User Specification

## Purpose

Human content.

## Generated Analysis

Old generated content that should be replaced.
`
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        writeMode: 'merge',
        updateConfig: false,
      });

      await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      const content = await readFile(join(tempDir, 'openspec/specs/user/spec.md'), 'utf-8');
      expect(content).toContain('Human content');
      expect(content).not.toContain('Old generated content');
      expect(content).toContain('## Generated Analysis');
      // Should contain new generated content (from the spec)
      expect(content).toContain('Purpose');
    });
  });

  describe('Config Update', () => {
    it('should update config.yaml with spec-gen metadata', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        version: '2.0.0',
        updateConfig: true,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      expect(report.configUpdated).toBe(true);

      const configPath = join(tempDir, 'openspec/config.yaml');
      const configContent = await readFile(configPath, 'utf-8');
      expect(configContent).toContain('spec-gen');
      expect(configContent).toContain('version');
      expect(configContent).toContain('domains');
    });

    it('should preserve existing config when updating', async () => {
      // Create existing config
      await mkdir(join(tempDir, 'openspec'), { recursive: true });
      await writeFile(
        join(tempDir, 'openspec/config.yaml'),
        `schema: custom-schema
context: User provided context
rules:
  specs:
    - must-have-purpose
`
      );

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        updateConfig: true,
      });

      await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      const configContent = await readFile(join(tempDir, 'openspec/config.yaml'), 'utf-8');
      expect(configContent).toContain('custom-schema');
      expect(configContent).toContain('must-have-purpose');
      expect(configContent).toContain('spec-gen');
    });
  });

  describe('Validation', () => {
    it('should validate specs before writing when enabled', async () => {
      const specs: GeneratedSpec[] = [
        {
          path: 'openspec/specs/bad/spec.md',
          content: 'Invalid spec without proper structure',
          domain: 'bad',
          type: 'domain',
        },
      ];

      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        validateBeforeWrite: true,
        updateConfig: false,
      });

      // Should still write but may log warnings
      const report = await writer.writeSpecs(specs, createMockSurvey());

      expect(report.filesWritten).toContain('openspec/specs/bad/spec.md');
    });
  });

  describe('getExistingDomains', () => {
    it('should return list of existing domain directories', async () => {
      await mkdir(join(tempDir, 'openspec/specs/user'), { recursive: true });
      await mkdir(join(tempDir, 'openspec/specs/auth'), { recursive: true });
      await mkdir(join(tempDir, 'openspec/specs/overview'), { recursive: true });

      const writer = new OpenSpecWriter({ rootPath: tempDir });
      const domains = await writer.getExistingDomains();

      expect(domains).toContain('user');
      expect(domains).toContain('auth');
      expect(domains).not.toContain('overview'); // Filtered out
    });
  });

  describe('Generation Report', () => {
    it('should include all required fields', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        version: '1.5.0',
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      expect(report.timestamp).toBeDefined();
      expect(report.specGenVersion).toBe('1.5.0');
      expect(report.filesWritten).toBeDefined();
      expect(report.filesSkipped).toBeDefined();
      expect(report.filesBackedUp).toBeDefined();
      expect(report.filesMerged).toBeDefined();
      expect(report.nextSteps).toBeDefined();
      expect(report.warnings).toBeDefined();
    });

    it('should include appropriate next steps', async () => {
      const writer = new OpenSpecWriter({
        rootPath: tempDir,
        updateConfig: false,
      });

      const report = await writer.writeSpecs(createMockSpecs(), createMockSurvey());

      expect(report.nextSteps.some(s => s.includes('openspec list'))).toBe(true);
      expect(report.nextSteps.some(s => s.includes('validate'))).toBe(true);
      expect(report.nextSteps.some(s => s.includes('verify'))).toBe(true);
    });
  });
});

describe('Convenience Functions', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  describe('writeOpenSpecs', () => {
    it('should write specs with default options', async () => {
      const specs = createMockSpecs();
      const survey = createMockSurvey();

      const report = await writeOpenSpecs(specs, survey, {
        rootPath: tempDir,
        updateConfig: false,
      });

      expect(report.filesWritten.length).toBeGreaterThan(0);
    });
  });

  describe('initializeOpenSpec', () => {
    it('should initialize directory structure', async () => {
      await initializeOpenSpec(tempDir);

      expect(await fileExists(join(tempDir, 'openspec/specs'))).toBe(true);
      expect(await fileExists(join(tempDir, '.spec-gen/analysis'))).toBe(true);
    });
  });
});

describe('Edge Cases', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('should handle empty specs array', async () => {
    const writer = new OpenSpecWriter({
      rootPath: tempDir,
      updateConfig: false,
    });

    const report = await writer.writeSpecs([], createMockSurvey());

    expect(report.filesWritten).toHaveLength(0);
    expect(report.nextSteps.length).toBeGreaterThan(0);
  });

  it('should handle special characters in domain names', async () => {
    const specs: GeneratedSpec[] = [
      {
        path: 'openspec/specs/user-profile/spec.md',
        content: '# User Profile\n\n## Purpose\n\nTest.',
        domain: 'user-profile',
        type: 'domain',
      },
    ];

    const writer = new OpenSpecWriter({
      rootPath: tempDir,
      updateConfig: false,
    });

    const report = await writer.writeSpecs(specs, createMockSurvey());

    expect(report.filesWritten).toContain('openspec/specs/user-profile/spec.md');
    expect(await fileExists(join(tempDir, 'openspec/specs/user-profile/spec.md'))).toBe(true);
  });

  it('should handle deeply nested paths', async () => {
    const specs: GeneratedSpec[] = [
      {
        path: 'openspec/specs/domain/subdomain/spec.md',
        content: '# Nested Spec\n\n## Purpose\n\nTest.',
        domain: 'subdomain',
        type: 'domain',
      },
    ];

    const writer = new OpenSpecWriter({
      rootPath: tempDir,
      updateConfig: false,
    });

    const report = await writer.writeSpecs(specs, createMockSurvey());

    expect(await fileExists(join(tempDir, 'openspec/specs/domain/subdomain/spec.md'))).toBe(true);
  });
});
